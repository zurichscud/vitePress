# 协变与逆变

协变和逆变是函数类型中的概念，用于解决两个函数类型什么时候可以赋值什么时候不能赋值

> **“返回值协变，参数逆变”**

## 协变

- **子类型可以“向上”替换**
- 适用于：函数的返回值**
- 直觉：**“我可以返回更具体的东西”**

```ts
class Animal {}
class Dog extends Animal {}

type Fn1 = () => Dog
type Fn2 = () => Animal

let f1: Fn1 = () => new Dog()
let f2: Fn2

f2 = f1 // ✅ OK，因为 Dog 是 Animal 的子类型

```

f2期待得到Animal类型，但是得到了Dog类型的对象，因此是安全的



## 逆变

- **父类型可以“向下”替换**

- 适用于：**函数参数**
- 直觉：**“我可以接受更宽泛的东西”**

```ts
class Animal {}
class Dog extends Animal {}

type Fn1 = (arg: Animal) => void
type Fn2 = (arg: Dog) => void

let f1: Fn1 = (a: Animal) => {}
let f2: Fn2

f2 = f1 // ✅ OK
// f1 = f2 // ❌ 不行

```

f1期望的是Animal，实际执行的却是Dog类型，会出现逻辑冲突

f2期望的是Dog，但是实际执行的却是Animal类型，就不会出现逻辑冲突

## **对象兼容原则**

- 成员必须“至少存在”

目标类型（左）需要的成员，源对象（右）必须**至少包含这些成员**，**多出的成员没关系**。

```ts
interface Named {
  name: string;
}

let x: Named;
x = { name: "Alice", age: 30 }; // ✅ 兼容，age 是多余的但没关系
```

-  成员类型必须兼容

不仅要有，类型还得对得上：

```ts
interface A {
  x: number;
}

let a: A = { x: "hello" }; // ❌ 错误，x 类型不匹配
```

::: tip 为什么至少存在？

变量在声明时类型就已经确定，后续的赋值操作必须兼容原来的类型，否则后续会出现逻辑错误

```ts
interface User {
  id: number;
  name: string;
}

function greet(u: User) {
  console.log(u.name.toUpperCase()); // 运行时假定 u.name 一定存在
}

greet({ id: 1 }); // ❌ 如果 TS 允许，这里就会抛 TypeError
```



:::