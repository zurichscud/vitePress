# 控制反转

## 控制反转

> **控制反转（Inversion of Control, IoC）** 是一种软件设计原则，它通过将对象的控制权从类自身转移到外部容器或框架中，从而减少了类与类之间的耦合关系，提高了灵活性和可扩展性。

在传统的面向对象编程中，类负责创建它所依赖的对象和管理自己的依赖。然而，控制反转改变了这种情况，它让外部容器或框架负责创建和管理这些依赖对象，而不是让类自己去创建。简单来说，**控制反转就是将控制权类本身转移到外部容器**，让容器来决定什么时候、如何创建对象以及如何注入它们的依赖。

## 依赖注入优势

依赖注入是控制反转的一种实现方式。通过依赖注入，外部容器负责将依赖对象注入到类中，而不是类自己去创建这些依赖。

- 硬编码方式

```ts [EmailService.ts]
// EmailService.ts
class EmailService {
  send(to: string, message: string) {
    console.log(`发送邮件给 ${to}: ${message}`);
  }
}
```

```ts [UserService.ts]
// UserService.ts
import { EmailService } from './EmailService';

class UserService {
  private emailService: EmailService;

  constructor() {
    // ❌ 缺点：UserService 主动创建了 EmailService 实例
    // 如果以后想换成 SMS 模块，或者想在测试时不发真实邮件，就得改代码
    this.emailService = new EmailService();
  }

  register(email: string) {
    console.log('用户注册成功');
    this.emailService.send(email, '欢迎加入！');
  }
}
```

- 使用依赖注入：

```js
// 定义一个接口（TS 的灵魂所在）
interface NotificationService {
  send(to: string, message: string): void;
}

// 邮件实现
class EmailService implements NotificationService {
  send(to: string, message: string) { console.log(`邮件通知: ${to}`); }
}

// 短信实现
class SmsService implements NotificationService {
  send(to: string, message: string) { console.log(`短信通知: ${to}`); }
}

// UserService 变被动了
class UserService {
  // ✅ 优点：UserService 不关心具体是谁发，只要符合接口就行
  constructor(private readonly notifier: NotificationService) {}

  register(email: string) {
    this.notifier.send(email, '欢迎！');
  }
}

// --- 在应用入口处执行“注入” ---
const emailSvc = new EmailService();
const userSvc = new UserService(emailSvc); // 注入 Email 服务
userSvc.register('test@example.com');
```

## 依赖注入类型

### 构造器注入

通过构造函数将依赖项传递给对象

```js
class Car {
  private engine: Engine;

  constructor(engine: Engine) {
    this.engine = engine; // engine是外部传入的依赖
  }

  start() {
    this.engine.run();
  }
}
```



### 属性注入

通过公开的属性将依赖项注入到对象中

```js
class Car {
  engine: Engine;

  setEngine(engine: Engine) {
    this.engine = engine; // engine是外部传入的依赖
  }

  start() {
    this.engine.run();
  }
}
```

### 方法注入

依赖通过方法传入。

```js
class Car {
  start(engine: Engine) {
    engine.run(); // engine是通过方法传入的依赖
  }
}
```



## 配置

`Inversify` 是一个用于 TypeScript 和 JavaScript 的轻量级依赖注入（DI）库，`reflect-metadata` 则是它依赖的一个库，用于支持 TypeScript 中的装饰器和元数据功能。结合使用这两个库，可以轻松实现基于装饰器的依赖注入。

```js
npm i inversify reflect-metadata
```

然后，确保在 TypeScript 项目中启用装饰器和反射元数据，编辑你的 `tsconfig.json`：

```json [tsconfig.json]
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  }
}
```

## 实现

### 依赖注入

首先，我们定义 `Engine` 接口和它的实现类 `GasEngine`：

```ts
// Engine.ts
export interface Engine {
  start(): string;
}

@injectable()  // 使用 @injectable 装饰器标记该类可以被注入
export class GasEngine implements Engine {
  start(): string {
    return "Gas engine started!";
  }
}
```

然后，定义 `Car` 类，它依赖于 `Engine`：

```js
// Car.ts
import { Engine } from './Engine';
import { injectable, inject } from "inversify";

@injectable()  // 使用 @injectable 装饰器标记该类可以被注入
export class Car {
  private engine: Engine;

  constructor(@inject("Engine") engine: Engine) {  // 使用 @inject 装饰器注入 Engine 依赖
    this.engine = engine;
  }

  startCar() {
    console.log(this.engine.start());  // 调用引擎的 start 方法
  }
}
```

- `@injectable()`：该装饰器标记类可以被 `InversifyJS` 容器管理。只有标记为 `@injectable` 的类才能被容器识别和注入。
- 如果没有显式指定标识符，`InversifyJS` 将会使用类名（例如 `"Car"`）作为该类的默认标识符。
- `@inject("Engine")`：将 `Engine` 类型的依赖注入到 `Car` 类中。这里 `@inject` 装饰器的参数 `"Engine"` 是在容器中用来标识依赖的标识符。

### IOC容器

```ts
// main.ts
import { Container } from "inversify";
import { Car } from './Car';
import { GasEngine } from './Engine';

const container = new Container();

// 将 GasEngine 类绑定到 "Engine" 这个标识符
container.bind<Engine>("Engine").to(GasEngine);

// 将 Car 类绑定到容器
container.bind<Car>(Car).toSelf();

// 从容器获取 Car 实例并启动
const myCar = container.get<Car>(Car);
myCar.startCar();  // 输出: "Gas engine started!"
```

- `container.bind<Engine>("Engine").to(GasEngine)`：告诉容器，当请求 `"Engine"` 时，提供 `GasEngine` 实例。

- `container.bind<Car>(Car).toSelf()`：告诉容器将 `Car` 类型的类绑定到自己，使得容器能够创建 `Car` 类的实例。