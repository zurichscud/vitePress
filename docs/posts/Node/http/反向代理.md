# 反向代理

## 概念

反向代理（Reverse Proxy）是一种网络通信模式，它充当服务器和客户端之间的中介，将客户端的请求转发到一个或多个后端服务器，并将后端服务器的响应返回给客户端。

负载均衡：反向代理可以根据预先定义的算法将请求分发到多个后端服务器，以实现负载均衡。这样可以避免某个后端服务器过载，提高整体性能和可用性。

高可用性：通过反向代理，可以将请求转发到多个后端服务器，以提供冗余和故障转移。如果一个后端服务器出现故障，代理服务器可以将请求转发到其他可用的服务器，从而实现高可用性。

缓存和性能优化：反向代理可以缓存静态资源或经常访问的动态内容，以减轻后端服务器的负载并提高响应速度。它还可以通过压缩、合并和优化资源等技术来优化网络性能。

安全性：反向代理可以作为防火墙，保护后端服务器免受恶意请求和攻击。它可以过滤恶意请求、检测和阻止攻击，并提供安全认证和访问控制。

域名和路径重写：反向代理可以根据特定的规则重写请求的域名和路径，以实现 URL 路由和重定向。这对于系统架构的灵活性和可维护性非常有用。



## http-proxy-middleware

是一个 **Node 代理中间件库**，常用于反向代理

```js
npm install http-proxy-middleware
```

- target 

目标服务器地址

```js
target: 'http://localhost:3000'
```

- changeOrigin

一般都要设为 true，否则有些服务器会拒绝。

```js
changeOrigin: true
```



- pathRewrite

路径重写

```js
pathRewrite: {
  '^/api': ''
}
// /api/user  →  /user
```



## 实现



```js [server1.js]
const http = require('http');
const url = require('url');
const {createProxyMiddleware} = require('http-proxy-middleware')
const config = require('./proxy.config')

const server = http.createServer((req, res) => {
    const {pathname} = url.parse(req.url)
    console.log(pathname);
    
    const proxyPaths = Object.keys(config.server.proxy)
    if (proxyPaths.includes(pathname)) {
        const proxy=createProxyMiddleware(config.server.proxy[pathname])
        proxy(req, res)
        return
    }
    res.end('common server')


}).listen(8888, () => {
  console.log('server listening on port 8888');
});

```



```js [proxy.config.js]
module.exports = {
    server:{
        proxy:{
            //代理配置，用于传入proxyMiddleware
            '/api': {
                target: 'http://localhost:9999', //转发的地址
                changeOrigin: true, //是否有跨域
            }
        }
    }
}
```



```js [server2.js]
const http = require('http');

http.createServer((request, response) => {

  response.end('proxy success');
}).listen(9999, () => {
  console.log('proxy server listening on port 9999');
});
```

