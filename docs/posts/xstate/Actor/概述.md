# 基本概念



当你运行一个状态机时，它就变成了一个 actor：一个可以接收事件、发送事件并根据接收到的事件改变其行为的运行进程



## Actor logic

Actor logic 是 actor 的逻辑"模型"（大脑、蓝图、DNA 等）。它描述了 actor 在接收到事件时应该如何改变行为。

| 类型          | 用途         |
| ------------- | ------------ |
| createMachine | 最强、最完整 |
| fromPromise   | 请求 / async |

在 XState 中，actor 逻辑由实现 `ActorLogic` 接口的对象定义，其中包含诸如 `.transition(...)`、`.getInitialSnapshot()`、`.getPersistedSnapshot()` 等方法。这个对象告诉解释器当接收到事件时如何更新 actor 的内部状态以及要执行哪些效果（如果有）。

|                                                              | Receive events | Send events | Spawn actors | Input | Output |
| ------------------------------------------------------------ | -------------- | ----------- | ------------ | ----- | ------ |
| [State machine actors](https://stately.ai/docs/state-machine-actors) | ✅              | ✅           | ✅            | ✅     | ✅      |
| [Promise actors](https://stately.ai/docs/promise-actors)     | ❌              | ✅           | ❌            | ✅     | ✅      |

### createMachine

您可以将 actor 逻辑描述为 [状态机 ](https://stately.ai/docs/machines)。actor可以做到：

- 接收事件
- 向其他Actor发送事件
- 调用/生成子级 Actor
- 发出其状态的快照
- 当机器到达其顶层最终状态时输出一个值

```ts
const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: {
        toggle: 'inactive'
      },
    },
    active: {
      on: {
        toggle: 'active'
      }
    },
  },
});

const toggleActor = createActor(toggleMachine);

toggleActor.subscribe((snapshot) => {
  // snapshot is the machine's state
  console.log('state', snapshot.value);
  console.log('context', snapshot.context);
});
toggleActor.start();
// Logs 'inactive'
toggleActor.send({ type: 'toggle' });
// Logs 'active'
```

### fromPromise

Promise actor 逻辑由一个异步过程描述，该过程会在一段时间后解析（resolve）或拒绝（reject）。从 promise 逻辑创建的 actor（"promise actors"）可以：

- 发出 promise 的解析值
- 输出 promise 的解析值

向 promise actor 发送事件将不会产生任何效果。

```ts
const promiseLogic = fromPromise(() => {
  return fetch('https://example.com/...').then((data) => data.json());
});

const promiseActor = createActor(promiseLogic);
promiseActor.subscribe((snapshot) => {
  console.log(snapshot);
});
promiseActor.start();
// => {
//   output: undefined,
//   status: 'active'
//   ...
// }

// After promise resolves
// => {
//   output: { ... },
//   status: 'done',
//   ...
// }
```



## 创建Actor

你可以通过 `createActor(actorLogic, options?)` 创建一个 actor，它是某种 actor 逻辑的"活动"实例。`createActor(...)` 函数接受以下参数：

- `actorLogic`: 用于创建 actor 的 [actor logic](https://stately.ai/docs/actors#actor-logic)
- `options`（可选）：actor 选项

当你通过 `createActor(actorLogic)` 从 actor 逻辑创建一个 actor 时，你隐式地创建了一个 [actor 系统 ](https://stately.ai/docs/system)，其中创建的 actor 是根 actor。从这个根 actor 及其后代生成的所有 actor 都是该 actor 系统的一部分。actor 必须通过调用 `actor.start()` 来启动，这也会启动 actor 系统：

```ts
import { createActor } from 'xstate';
import { someActorLogic } from './someActorLogic.ts';

const actor = createActor(someActorLogic);

actor.subscribe((snapshot) => {
  console.log(snapshot);
});

actor.start();

// Now the actor can receive events
actor.send({ type: 'someEvent' });
```

您可以通过调用 `actor.stop()` 来停止根 actor，这也会停止该 actor 系统以及该系统中的所有 actor：

```ts
// Stops the root actor, actor system, and actors in the system
actor.stop();
```

## Actor 快照

### 基本概念

当一个 actor 接收到事件时，其内部状态可能会发生变化。当状态发生转换时，actor 可能会发出一个快照。你可以通过 `actor.getSnapshot()` 同步读取 actor 的快照，或者通过 `actor.subscribe(observer)` 订阅快照。

### getSnapshot

```ts
import { fromPromise, createActor } from 'xstate';

async function fetchCount() {
  return Promise.resolve(42);
}

const countLogic = fromPromise(async () => {
  const count = await fetchCount();

  return count;
});

const countActor = createActor(countLogic);

countActor.start();

countActor.getSnapshot(); // logs undefined

// After the promise resolves...
countActor.getSnapshot();
// => {
//   output: 42,
//   status: 'done',
//   ...
// }
```

### subscribe

您可以通过 `actor.subscribe(observer)` 订阅一个 actor 的快照值。当快照值发出时，观察者将接收该值。观察者可以是：

- 一个接收最新快照的普通函数，
- 一个观察者对象，其 `.next(snapshot)` 方法接收最新的快照
- 使用 `error` 回调来订阅 actor 抛出的错误。这使您能够处理由 actor 逻辑发出的错误。

```ts
// Observer as a plain function
const subscription = actor.subscribe((snapshot) => {
  console.log(snapshot);
});
```

```ts
// Observer as an object
const subscription = actor.subscribe({
  next(snapshot) {
    console.log(snapshot);
  },
  error(err) {
    // ...
  },
  complete() {
    // ...
  },
});
```

`actor.subscribe(observer)` 的返回值是一个订阅对象，它有一个 `.unsubscribe()` 方法。你可以调用 `subscription.unsubscribe()` 来取消订阅观察者：

```ts
const subscription = actor.subscribe((snapshot) => {
  /* ... */
});

// Unsubscribe the observer
subscription.unsubscribe();
```

当 actor 停止时，其所有观察者将自动取消订阅。

### 持久化

您可以通过在 `createActor(logic, options)` 的第二个 `options` 参数中传入状态，来在特定的持久化快照（状态）中初始化 actor 逻辑。如果该状态与 actor 逻辑兼容，这将创建一个在该持久化状态启动的 actor：

```ts
const persistedState = JSON.parse(localStorage.getItem('some-persisted-state'));

const actor = createActor(someLogic, {
  snapshot: persistedState,
});

actor.subscribe(() => {
  localStorage.setItem(
    'some-persisted-state',
    JSON.stringify(actor.getPersistedSnapshot()),
  );
});

// Actor will start at persisted state
actor.start();
```

## waitFor

你可以使用 `waitFor(actor, predicate, options?)` 辅助函数等待一个 actor 的快照满足某个谓词条件。`waitFor(...)` 函数返回一个 promise，该 promise：

- 当发出的快照满足 `predicate` 函数时解析
- 如果当前快照已经满足 `predicate` 函数，则立即解决
- 如果抛出错误或 `options.timeout` 值超时，则会被拒绝。

```ts
import { waitFor } from 'xstate';
import { countActor } from './countActor.ts';

const snapshot = await waitFor(
  countActor,
  (snapshot) => {
    return snapshot.context.count >= 100;
  },
  {
    timeout: 10_000, // 10 seconds (10,000 milliseconds)
  },
);

console.log(snapshot.output);
// => 100
```

## Actor 作为 Promise

您可以通过使用 `toPromise(actor)` 函数从任何 actor 创建一个 promise。当 actor 完成（`snapshot.status === 'done'`）时，promise 将使用 actor 快照的 `.output` 解析，或者当 actor 出错（`snapshot.status === 'error'`）时，promise 将使用 actor 快照的 `.error` 拒绝。

```ts
import { createMachine, createActor, toPromise } from 'xstate';

const machine = createMachine({
  // ...
  states: {
    // ...
    done: { type: 'final' },
  },
  output: {
    count: 42,
  },
});

const actor = createActor(machine);
actor.start();

// Creates a promise that resolves with the actor's output
// or rejects with the actor's error
const output = await toPromise(actor);

console.log(output);
// => { count: 42 }
```

如果 actor 已经完成，promise 将立即使用 actor 的 `snapshot.output` 解析。如果 actor 已经出错，promise 将立即使用 actor 的 `snapshot.error` 拒绝。

## 嵌套的Actor

> **在 XState 里“不是只有一个状态机”，事件必须知道“发给谁”。**

```ts
Parent Actor
├── Form Actor
├── Fetch Actor
└── Timer Actor

```

保证事件“只被一个 actor 消费”：

```ts
send({ type: 'RESET' }, { to: 'form' });//明确告诉状态机，不是给我自己的，是给actor的
```
