# Actor Model

## Actor的特点



- **封装（Encapsulation）**：一个Actor拥有自己内部的、封装的状态，该状态只能由actor自身更新。actor可以选择在接收到消息时更新其内部状态，但不能被任何其他实体更新。

- **消息异步传递（Asynchronous Messaging）**：actor 间通过消息异步交互。
- **并发与独立性（Concurrency）**：每个 actor 独立运行，可以并发处理（逻辑上并发）。
- **生命周期与监督（Lifecycle / Supervision）**：actor 有启动、停止、失败等生命周期，常由上级管理。
- 内部的actor状态不会在actor之间共享。actor共享其内部状态的任何部分的唯一方法是：
  - 向其他actor发送事件
  - 或者发出快照，这些快照可以被视为发送给订阅者的隐式事件。
- Actor 可以创建（生成/调用）新的 Actor。

## Actor的生命周期

Actor 的生命周期与其被托管的状态节点绑定（invoke）或独立（spawn）。

- **创建/启动**：进入某个 state，XState 创建 actor 实例并传入 `input`（如果有）。
- **运行中（pending）**：actor 执行业务逻辑，可发送事件到父机或其他 actor（若设计允许）。
- **完成 / 失败**：actor 成功返回 → XState 发 `done` 事件；失败 → `error` 事件。
- **停止/取消**：离开 state（或被 supervisor 停止）时，XState 会 stop actor（不再处理其后续结果/事件）。



## Actor的通信模式

Actor之间只能通过event进行通信。

- **父 ← 子（onDone / onError / event.output）**：invoke 自动发送 done/error。

```ts
{
  type: 'xstate.done.actor.getUser',
  output: user
}
```

- **父 ↔ 子（send/to）**：父机可用 `send(..., { to: actorId })` 直接向某 actor 发消息。

- **actor → 父机（sendBack）**：在 fromCallback 等可主动发送事件给父机。

- **actor ↔ actor（中介或路由）**：通过父机或专门的 router actor 转发消息。



## Actor的输入和输出

一个Actor实例的输入是可选的。

只有“会结束（complete）”的 actor，才可能产生 `output`，“返回值”只存在于 **“完成（done）事件”** 中。



